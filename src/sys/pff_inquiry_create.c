/*-------------------------------------------------------------------------*
 *  Source Code:    %M%
 *-------------------------------------------------------------------------*
 *  Version:        %I%
 *  Version Date:   %G% - %U%
 *  Source Date:    %H% - %T%
 *
 *  Description:    Product file formated query report creation.
 *
 *-------------------------------------------------------------------------*
 *                            Revision history                             |
 *-------------+-----------------------------------------------------------*
 * Change Date |            Author & Description                           |
 *-------------+-----------------------------------------------------------*
 *  10/28/93   |  tjt Added to mfc.
 *  07/22/95   |  tjt Revise Bard calls.
 *  08/23/96   |  tjt Add begin and commit work.
 *-------------------------------------------------------------------------*/
static char pff_inquiry_create_c[] = "%Z% %M% %I% (%G% - %U%)";

/************************************************************************/
/*                                                                      */
/*      pff_inquiry_create.c                                            */
/*                                                                      */
/*      This program creates the product file formatted inquiry report. */
/*      The report is created in 4 steps, as follows:                   */
/*                                                                      */
/*      step 1. An SQL query is created and run on the selection        */
/*              criteria. The query collects the following fields:      */
/*              pfsku, fgroup, pmodno, and stkloc.                      */
/*                                                                      */
/*      step 2. The pick modules are checked                            */
/*              to be in the operator's pickline(s).                    */
/*                                                                      */
/*      step 3. The file resulting from step 2 is now sorted using      */
/*              a UNOS utility, according to the entered sorting        */
/*              criteria.                                               */
/*                                                                      */
/*      step 4. The records in the sorted file are now processed,       */
/*              and the resulting SKU Information and PM information    */
/*              records are written to the final file for output.       */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include "iodefs.h"
#include "ss.h"
#include "co.h"
#include "pff_defs.h"
#include "pff_inquiry_report.t"           /* for database_report             */
#include "Bard.h"
#include "bard/prodfile.h"
#include "bard/pmfile.h"

prodfile_item sk;                         /* structure for SKU               */
pmfile_item pm;                           /* structure for PM                */

/* lookup types. these are used to determine usable size of range buffers */

#define NO_LOOK         0
#define SKU_LOOK        1
#define FGROUP_LOOK     2
#define STKLOC_LOOK     3

#define RECORD_SIZE     39           /* size of record generated by SQL query*/

/* arguments to main:

        argv[1] is the operator's pickline number.
        argv[2] is the selection mode (either s,l,p or f).
        argv[3] is sort mode as defined in pff_defs.h.
        argv[4] is the first range buffer from the input screen.
        argv[5] is the second range buffer.
        argv[6] unused.
        argv[7] is the print/report screen flag, which tells this
                program where to end up (either "print" or "report").
*/

  char data_file[5][16];                /* file 0 holds SQL query           */
                                        /* file 1 holds results of SQL      */
                                        /* file 2 has selected recs. from 1 */
                                        /* file 3 has file 2 sorted         */
                                        /* file 4 is final output file      */

  char cmd_buf[100];                      /* holds system commands           */

  char print_file[16];                    /* required for prft routine       */

  char rng_buf[2][16];                    /* lower and upper ranges          */
  char rec_buf[RECORD_SIZE + 1];          /* holds rec from SQL result       */
  char work[64];
  char PM_buf[5];                         /* ascii of a PM number            */
  long PM_num;                            /* derived from PM_buf             */
  char cur_SKU[16];                       /* current SKU                     */
  char last_SKU[16];                      /* last accessed SKU               */


long pm_tab_size=0;                       /* size of config.pm file          */

char main_setup[] = "select pfsku, fgroup, pmodno, stkloc\n";

main(argc,argv)
int argc;
char **argv;
{
  extern leave();
  char *strtok(), *p1, *p2, *p3, *p4;
  
        /* file descriptors and temporary file names:

                the large number of filenames and file descriptors
                is included for simplification of maintenance and
                debugging. each file descriptor points to the 
                appropriate file...
        */

  FILE *fp0;
  FILE *fp1;
  FILE *fp2;
  FILE *fp3;
  FILE *fp4;

  char selection = *argv[2];              /* code, either p,s,f or l         */
  char expand_sel[10];                    /* full name of UNIFY field        */
  short sort_mod = atoi(argv[3]);         /* requested sort mode             */
  short lookup;                           /* holds values defined above      */
  char qsopt[10];                         /* holds options for quicksort     */

  short found=0;                          /* first record found flag         */
  short all_list=0;                       /* 'All' records requested flag    */

  unsigned char pickline;

  char c;                                 /* general purpose                 */
  short ret,i,j,k,n;                      /* general purpose                 */

  putenv("_=pff_inquiry_create");
  chdir(getenv("HOME"));
  
  open_all();

#ifdef DEBUG
  for (k =0; k < argc; k++)
  {
    fprintf(stderr, "argv[%d] = [%s]\n", k, argv[k]);
  }
#endif
  
  pickline = atol(argv[1]);

        /****************************************/
        /* clear command and range buffers.     */
        /* get temporary file names.            */
        /****************************************/

  for(i=0;i<100;i++) cmd_buf[i] = 0;
  for(i=0;i<2;i++)
  {
    for(n=0;n<16;n++) rng_buf[i][n] = 0;
  }
  for(i = 0; i < 5; i++) tmp_name(data_file[i]);

        /******************************/
        /* create SQL query in file 0 */
        /******************************/

  fp0 = fopen(data_file[0], "w");         /* main SQL query                  */
  fprintf(fp0, main_setup);               /* initial text                    */

  switch(selection)
  {
    case 'p':                             /* pick module                     */
      fprintf(fp0," from pmfile, prodfile\nwhere ");
      strcpy(expand_sel,"pmodno");
      break;

    case 'l':                             /* stock location                  */
      fprintf(fp0," from pmfile, prodfile\nwhere ");
      strcpy(expand_sel,"stkloc");
      break;

    default:
    case 's':                             /* SKU                             */
      fprintf(fp0," from prodfile, pmfile\nwhere ");
      strcpy(expand_sel,"pfsku");
      break;

    case 'f':                             /* family group                    */
      fprintf(fp0," from prodfile, pmfile\nwhere ");
      strcpy(expand_sel,"fgroup");
      break;
    }

  if(!streql("0",argv[4]))                /* if 'All' not chosen             */
  {
    fprintf(fp0,"%s ",expand_sel);        /* selection                       */
    if(streql("0",argv[5]))               /* 2nd buf empty                   */
    {
      if(selection == 'p')                /* pick module selection           */
      fprintf(fp0,"= %s ",argv[4]);
      else                                /* pfsku, fgroup, stkloc           */
      fprintf(fp0,"= '%s' ",argv[4]);
    }
    else                                  /* range request                   */
    {
      if(selection != 'p')                /* not pick module select          */
      fprintf(fp0," between '%s' and '%s' ",argv[4], argv[5]);
      else                                /* PM select                       */
      fprintf(fp0, " between %s and %s ",argv[4], argv[5]);
    }
    fprintf(fp0,"and ");
  }
  else all_list = 1;                      /* set 'All' requested flag        */

  fprintf(fp0,"pmsku = pfsku\norder by %s",expand_sel);
  fprintf(fp0,"\n");                     /* termination sequence            */
  fclose(fp0);

        /***********************************************/
        /* run SQL query. data received in data_file 2 */
        /***********************************************/

  sprintf(cmd_buf, "SQL %s %s", data_file[0], data_file[1]);
  system(cmd_buf);

#ifndef DEBUG
  unlink(data_file[0]);                  /* DELETE FILE 0                   */
#endif
        /*************************************/
        /* process data created by SQL query */
        /*************************************/


        /* find usable records... */

  fp1 = fopen(data_file[1], "r");
  fp2 = fopen(data_file[2], "w");

  while (fgets(work, 40, fp1))
  {
    p1 = strtok(work, "|");
    p2 = strtok(0, "|");
    p3 = strtok(0, "|");
    p4 = strtok(0, "|");
    
    sprintf(rec_buf, "%-15.15s|%-5.5s|%9.9s|%-6.6s\n", p1, p2, p3, p4);

    if (check_pl(rec_buf, pickline)) fwrite(rec_buf, RECORD_SIZE, 1, fp2);
  }
  fclose(fp1);
  fclose(fp2);

#ifndef DEBUG
  unlink(data_file[1]);                  /* DELETE FILE 1                   */
#endif

        /*************************************************************/
        /* file 2 now contains all the good records. time to sort... */
        /* field 1 is pfsku, 2 is fgroup, 3 is pmodno, 4 is stkloc.  */
        /*************************************************************/
#ifdef INTEL
  switch(sort_mod)
  {
    case(PFF_P):
    strcpy(qsopt,"+2 -3");
    break;

    case(PFF_L):
    strcpy(qsopt,"+3 -4");
    break;

    case(PFF_S):
    case(PFF_SP):
    strcpy(qsopt,"+0 -1 +2 -3");
    break;

    case(PFF_SL):
    strcpy(qsopt,"+0 -1 +3 -4");
    break;

    case(PFF_F):
    case(PFF_FS):
    case(PFF_FSP):
    strcpy(qsopt, "+1 -2 +0 -1 +2 -3");
    break;

    case(PFF_FP):
    strcpy(qsopt,"+1 -2 + 2 -3");
    break;

    case(PFF_FL):
    strcpy(qsopt,"+1 -2 +3 -4");
    break;

    case(PFF_FSL):
    strcpy(qsopt,"+1 -2 +0 -1 +3 -4");
    break;
  }
  sprintf(cmd_buf,"sort \"-t|\" %s %s > %s",
    qsopt, data_file[2], data_file[3]);

#else
  switch(sort_mod)
  {
    case(PFF_P):
    strcpy(qsopt,"f=3");
    break;

    case(PFF_L):
    strcpy(qsopt,"f=4");
    break;

    case(PFF_S):
    case(PFF_SP):
    strcpy(qsopt,"f=1,3");
    break;

    case(PFF_SL):
    strcpy(qsopt,"f=1,4");
    break;

    case(PFF_F):
    case(PFF_FS):
    case(PFF_FSP):
    strcpy(qsopt,"f=2,1,3");
    break;

    case(PFF_FP):
    strcpy(qsopt,"f=2,3");
    break;

    case(PFF_FL):
    strcpy(qsopt,"f=2,4");
    break;

    case(PFF_FSL):
    strcpy(qsopt,"f=2,1,4");
    break;
  }
  sprintf(cmd_buf,"quicksort %s \"d=|\" %s > %s",
    qsopt, data_file[2], data_file[3]);
#endif

  system(cmd_buf);
  
#ifndef DEBUG
  unlink(data_file[2]);                    /* DELETE FILE 2                  */
#endif
        /**********************************************/
        /* process records - create SKU and PM report */
        /**********************************************/

  database_open();
  pmfile_open(READONLY);
  pmfile_setkey(1);
  prodfile_open(READONLY);
  prodfile_setkey(1);

  for(i=0;i<16;i++)
  {
    cur_SKU[i] = 0;
    last_SKU[i] = 0;
  }
  fp3 =fopen(data_file[3], "r");
  fp4 =fopen(data_file[4], "w");          /* final file to write             */

  while (fread(rec_buf, RECORD_SIZE, 1, fp3) > 0)
  {
    movebytes(rec_buf,cur_SKU,15);
    cur_SKU[15] = 0;
    if(streql(cur_SKU,last_SKU))          /* must be additional PM           */
    {
      begin_work();
      process_pm(rec_buf,&pm,fp4);
      commit_work();
    }
    else                                  /* new SKU                         */
    {
      strcpy(last_SKU,cur_SKU);
      memcpy(sk.p_pfsku, cur_SKU, 15);
      begin_work();
      if (!prodfile_read(&sk, NOLOCK))
      {
        pr_SKU_data(&sk,fp4);
        process_pm(rec_buf,&pm,fp4);
      }
      commit_work();
    }
  }
  pmfile_close();
  prodfile_close();
  database_close();
  
  fclose(fp3);
  fclose(fp4);
#ifndef DEBUG
  unlink(data_file[3]);                  /* DELETE FILE 3                   */
#endif
        /* determine how to exit */

  close_all();
  if(streql(argv[7],"report"))            /* go to report program            */
  {
    execlp("pff_inquiry_report","pff_inquiry_report", data_file[4],0);
    krash("main", "pff_inquiry_report load", 1);

  }
  else                                    /* print in background             */
  {
    execlp("pff_print", "pff_print", data_file[4], 0);
    krash("main", "pff_print load", 1);
  }
}                                         /* END OF MAIN                     */

/********************************************************/
/*      functions for pff_inquiry_create                */
/********************************************************/

/* process_pm():

   this routine finds the pick module number in the passed record buf
   and if non-zero calls pr_PM_data to print the pick module information.
*/

process_pm(buf,pm,fp)
char *buf;                                /* record buffer                   */
pmfile_item *pm;                          /* passed to print pm data function*/
FILE *fp;                                 /* passed to print pm data function*/
{
  char PM_buf[5];
  long PM_num;                            /* used for access to UNIFY        */
  short n;

  for(n=0;n<5;n++)
  PM_buf[n] = 0;
  for(n=4;n>=0;n--)
  {
    if(buf[27+n]==SPACE)
    {
      break;
    }
    else
    PM_buf[n]=buf[27+n];
  }
  while(n>=0)
  PM_buf[n--]='0';
  PM_num=atol(PM_buf);
  if(PM_num)
  {
    pm->p_pmodno = PM_num;
    if (!pmfile_read(pm, NOLOCK)) pr_PM_data(pm,fp);
  }
}

/* pr_SKU_data() and pr_PM_data():

   these routines print the SKU or PM data to the file.
*/

pr_SKU_data(sk,fpw)                       /* print out SKU data              */
prodfile_item *sk;
FILE *fpw;
{

  fprintf(fpw,"SKU Information:%63c\n", ' ');
  fprintf(fpw,"SKU%19c%-15.15s%12cBackup Stock Loc.       %-6.6s\n",
  ' ', sk->p_pfsku, ' ', sk->p_bsloc);
  fprintf(fpw,"Description%11c%-25.25s  Alt. Backup Stock Loc.  %-6.6s\n",
  ' ', sk->p_descr, sk->p_absloc);
  fprintf(fpw,"Carton Qty.%11c%-3d%24cInner Pack Qty.%9c%-3d   \n",
  ' ', sk->p_cpack, ' ', ' ', sk->p_ipqty);
  fprintf(fpw,"Family Group%10c%-5.5s%22cU/M%21c%-3.3s   \n%79c\n",
  ' ', sk->p_fgroup, ' ', ' ', sk->p_um, ' ');

}

pr_PM_data(pm,fpw)                        /* print out PM data               */
pmfile_item *pm;
FILE *fpw;
{

  fprintf(fpw,"Pick Module Information:%55c\n", ' ');
  fprintf(fpw,"Pick Module No.       %-5d%22cQty On Hand%13c%-5d \n",
  pm->p_pmodno, ' ', ' ', pm->p_qty);
  fprintf(fpw,"Pick Location Index   %d%26cRestock Point%11c%-5d \n",
  pm->p_plidx, ' ', ' ', pm->p_restock);
  fprintf(fpw,"CAPS Stock Location   %-6.6s%21cLane Capacity%11c%-5d \n",
  pm->p_stkloc, ' ', ' ', pm->p_lcap);
  fprintf(fpw,"Pick Inhibit%10c%c%26cRestock Flag%12c%c     \n%79c\n",
  ' ', pm->p_piflag,' ', ' ', pm->p_rsflag, ' ');
  fprintf(fpw,"Units Current Per.    %-7d%20cUnits Cum Period%8c%-6d\n",
  pm->p_cuunits, ' ', ' ', pm->p_cmunits);
  fprintf(fpw,"Lines Current Per.    %-7d%20cLines Cum Period%8c%-6d\n",
  pm->p_culines, ' ', ' ', pm->p_cmlines);
  fprintf(fpw,
  "Receipts Current Per. %-7d%20cReceipts Cum Period%5c%-6d\n%79c\n",
  pm->p_curecpt, ' ', ' ', pm->p_cmrecpt, ' ');
}

/* check_pl():

        this routine checks the pickline in the SQL query result record
        to be within the view of the operator (in operator's pickline,
        and if all, non-zero). returns 1 if yes, 0 if no.
*/

check_pl(buf, pickline)               /* check that module is in operator pl*/
char *buf;
short pickline;
{
  char pm_buf[6];
  long PM_num;
  unsigned char pl;
  short i=0;
    
  strncpy(pm_buf,buf+26,5);               /* get PM number                   */
  for(i=0;i<5;i++)
  {
    if(pm_buf[i]==SPACE)
    pm_buf[i]='0';                        /* spaces to ascii to zero         */
    else
    break;                                /* stop this foolishness           */
  }
  pm_buf[5] = 0;                          /* terminate                       */
  PM_num = atoi(pm_buf);

  if (!pickline) return 1;                 /* any pickline OK                */
  if (pickline == find_pickline(PM_num)) return 1;

  return 0;
}

find_pickline(prod)
register long prod;
{
  register struct hw_item   *h;
  register struct pw_item   *i;
  register struct bay_item  *b;
  register struct zone_item *z;
  
  if (prod < 1 || prod > coh->co_prod_cnt) return 0;
  
  i = &pw[prod - 1];

  h = &hw[i->pw_ptr - 1];
  if (!h->hw_bay) return 0;               /* no bay for light                */
  
  b = &bay[h->hw_bay - 1];
  if (!b->bay_zone) return 0;             /* no zone for bay                 */
  
  z = &zone[b->bay_zone - 1];
  
  return z->zt_pl;                        /* pickline or zero                */
}

open_all()
{
  ss_open();
  co_open();
}

close_all()
{
  ss_close();
  co_close();
}

leave()                                  /* for use during power failure only*/
{
  close_all();
  execlp("mmenu", "mmenu", 0);
  krash("leave", "mmenu load", 1);
}

/* end of pff_inquiry_create.c */
